# Core Workflow

Stryx enforces a strict separation between **experimentation** (scratches) and **reproduction** (canonical recipes). This prevents the "I ran it with some flag but forgot which one" problem.

## The Lifecycle

1.  **Experiment (`try`)**: Run quickly with overrides. Auto-saves to `configs/scratches/`.
2.  **Canonicalize (`new` / `fork`)**: Save a clean recipe to `configs/`.
3.  **Reproduce (`run`)**: Execute a canonical recipe exactly as defined. No overrides allowed.

## Commands

### `try`: The Scratchpad
Use `try` when you want to iterate quickly.

```bash
uv run train.py try lr=1e-3 batch_size=64
```

- **Behavior**:
    1.  Loads defaults (or a base config).
    2.  Applies overrides.
    3.  Generates a name: `YYYYMMDD_HHMM_petname` (e.g., `20231027_1030_zippy-zebra`).
    4.  Saves to `configs/scratches/`.
    5.  Runs it.
- **Output**: You get a reproducible record in `scratches/` without cluttering your main config list.

### `new` & `fork`: Canonical Recipes
Use these when you want to define a permanent experiment.

**Start Fresh:**
```bash
uv run train.py new baseline model=resnet50
```
Creates `configs/baseline.yaml`.

**Branching:**
```bash
uv run train.py fork baseline large_batch batch_size=256
```
Creates `configs/large_batch.yaml` based on `baseline`.

### `run`: Strict Reproduction
Use `run` to execute a saved recipe exactly.

```bash
uv run train.py run baseline
```

- **Strictness**: `run` **rejects** overrides (`run baseline lr=1e-4` is an error).
- **Why?** To ensure that if you say "I ran baseline", you ran *exactly* what is in `configs/baseline.yaml`. To change it, you must `fork` or `try`.

## Directory Structure

```text
project/
├── configs/
│   ├── baseline.yaml       # Canonical recipes
│   ├── experiment_A.yaml
│   └── scratches/          # Auto-generated by 'try'
│       ├── 2023...zebra.yaml
│       └── ...
└── runs/
    └── <run_id>/           # Output artifacts
        ├── config.yaml     # The exact config used
        ├── manifest.yaml   # Status, timestamps, result
        ├── stdout.log      # Captured logs
        └── git.patch       # Code snapshot
```
